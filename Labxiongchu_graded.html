<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <title>Lab 2 Feedback - xiongchu-graded</title>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; margin: 20px; }
        h1, h2, h3 { color: #333; }
        table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }
        table, th, td { border: 1px solid #ccc; }
        th, td { padding: 10px; text-align: left; }
        .commendation { color: green; }
        .deduction { color: red; }
        .suggestion { color: blue; }
        .code-block { background-color: #f9f9f9; border-left: 3px solid #ccc; padding: 10px; margin: 10px 0; }
        pre { margin: 0; }
        .grade { color: green; }
    </style>
</head>
<body>
    <h1>Lab 2 - Exceptions</h1>
    <table>
        <tr>
            <th>Earned</th>
            <th>Possible</th>
            <th>Criteria</th>
        </tr>
        <tr>
            <td>15</td>
            <td>15</td>
            <td>Intermediate Commits</td>
        </tr>
        <tr>
            <td>40</td>
            <td>60</td>
            <td>Technical Quality (see point deductions in code)</td>
        </tr>
        <tr>
            <td>10</td>
            <td>15</td>
            <td>Coding Standard Compliance and Program Clarity</td>
        </tr>
        <tr>
            <td>10</td>
            <td>10</td>
            <td>Following Submission Instructions</td>
        </tr>
    </table>

    <h2>Feedback</h2>
    <p>Chuakun,</p>
    <p>Thank you for your submission of Lab 2. You've demonstrated a good understanding of exception handling and input validation. However, there are several areas where improvements can enhance the robustness and clarity of your code. The code has some issues that need to be addressed to ensure proper functionality and maintainability. Check out the suggestions for improvement and make sure you go through them to enhance your skills.</p>

    <h2>Detailed Feedback</h2>

    <h3>Die.java</h3>
    <div class="code-block">
        <pre>
    /*
     * Course: CSC1020
     * Lab 2 - Exceptions
     * Die class
     * Name: Chuakun Xiong
     * Last Updated: 9/18/2024
     */
    package xiongchu;

    import java.util.Random;

    /**
     * Creates the Die class to have functionality of a die
     */
    public class Die {
        /**
         * Holds the minimum side to a die
         */
        public static final int MIN_SIDES = 2;
        /**
         * Holds the maximum side to a die
         */
        public static final int MAX_SIDES = 100;
        private int currentValue;
        private final int numSides;
        private final Random random = new Random();

        /**
         * A constructor that determines the sides of the dice
         * @param numSides keeps track of the number of sides on the die
         */
        public Die(int numSides) {
            this.numSides = numSides;
        }

        /**
         * Returns the current value of the dice and sets the
         * currentValue back to zero so the Die must be rolled again.
         * @return returns the last value generated by rolling the Die
         */
        public int getCurrentValue() {
            int temp = currentValue;
            currentValue = 0;
            return temp;
        }

        /**
         * Generates a random number from 2 to whatever value
         * the individual sets for number of sides
         */
        public void roll() {
            currentValue = random.nextInt(1, numSides + 1);
        }
    }
        </pre>
    </div>

    <p><span class="deduction"><strong>Deduction (-0.5):</strong></span> <strong>Exception Handling Misuse:</strong> The `DieNotRolledException` is intended to indicate that a die has not been rolled. However, in `Driver.java`, it's incorrectly thrown when the number of dice (`dieVal1`) is out of the allowed range (2 to 10).</p>

    <p><span class="deduction"><strong>Deduction (-0.5):</strong></span> <strong>Incorrect `String.format` Specifier:</strong> In the `report` method, `String.format` uses the `%o` specifier, which formats numbers in octal. This likely was intended to be `%d` for decimal formatting.</p>

    <p><span class="deduction"><strong>Deduction (-0.5):</strong></span> <strong>Logic Error in `report` Method:</strong> The logic for determining the number of asterisks (`*`) in the bar chart is flawed. It appends a `*` for each increment of 10% of the maximum roll count that the current roll count exceeds. However, the loop uses `MAX_DICE` (which is unrelated) as the upper bound for scaling.</p>

    <p><span class="deduction"><strong>Deduction (-0.5):</strong></span> <strong>Inefficient `rollDice` Implementation:</strong> The `rollDice` method uses nested loops to match roll sums with possible outcomes, which is inefficient, especially for a large number of dice or sides.</p>

    <p><span class="deduction"><strong>Deduction (-0.5):</strong></span> <strong>Potential Resource Leak:</strong> The `Scanner` object in `getInput` is not closed after use.</p>

    <p><span class="deduction"><strong>Deduction (-0.5):</strong></span> <strong>Typographical Errors:</strong> In `Die.java`: "keeps track fo the number of sides" (`fo` should be `of`).</p>

    <p><span class="deduction"><strong>Deduction (-0.5):</strong></span> <strong>Constructor Documentation:</strong> The constructor documentation mentions "keeps track fo the number of sides" with a typo.</p>

    <p><span class="suggestion"><strong>Suggestion for Improvement:</strong></span> 
        <ol>
            <li>Ensure that exceptions are thrown in appropriate contexts. Use `DieNotRolledException` only when a die hasn't been rolled before accessing its value.</li>
            <li>Replace `%o` with `%d` in `String.format` to correctly format decimal numbers.</li>
            <li>Revise the logic in the `report` method to accurately represent roll frequencies without tying it to `MAX_DICE`.</li>
            <li>Optimize the `rollDice` method by directly calculating the index for `listOfRolls` based on the sum, eliminating unnecessary nested loops.</li>
            <li>Close the `Scanner` instance after use or utilize a try-with-resources statement to prevent resource leaks.</li>
            <li>Correct typographical errors in comments and documentation to maintain professionalism and clarity.</li>
        </ol>
    </p>

    <div class="code-block">
        <pre>
    /**
     * Creates the Die class to have functionality of a die
     */
    public class Die {
        public static final int MIN_SIDES = 2;
        public static final int MAX_SIDES = 100;
        private int currentValue;
        private final int numSides;
        private final Random random = new Random();

        /**
         * A constructor that determines the sides of the dice
         * @param numSides keeps track of the number of sides on the die
         */
        public Die(int numSides) {
            if (numSides < MIN_SIDES || numSides > MAX_SIDES) {
                throw new IllegalArgumentException("Number of sides must be between " + MIN_SIDES + " and " + MAX_SIDES + ".");
            }
            this.numSides = numSides;
            this.currentValue = 0;
        }

        /**
         * Returns the current value of the dice and sets the
         * currentValue back to zero so the Die must be rolled again.
         * @return returns the last value generated by rolling the Die
         * @throws DieNotRolledException if the die has not been rolled
         */
        public int getCurrentValue() {
            if (currentValue == 0) {
                throw new DieNotRolledException();
            }
            int temp = currentValue;
            currentValue = 0;
            return temp;
        }

        /**
         * Generates a random number from 1 to the number of sides
         */
        public void roll() {
            currentValue = random.nextInt(1, numSides + 1);
        }
    }
        </pre>
    </div>

    <h3>DieNotRolledException.java</h3>
    <div class="code-block">
        <pre>
    /*
     * Course: CSC1020
     * Lab 2 - Exceptions
     * DieNotRolledException class
     * Name: Chuakun Xiong
     * Last Updated: 9/18/2024
     */
    package xiongchu;

    /**
     * A new exception in case a die is not rolled
     */
    public class DieNotRolledException extends RuntimeException {

        /**
         * a constructor that calls the super class
         */
        public DieNotRolledException() {
            super();
        }

        @Override
        public String getMessage() {
            return "DieNotRolledException";
        }
    }
        </pre>
    </div>

    <p><span class="deduction"><strong>Deduction (-0.5):</strong></span> <strong>Method <code>getMessage()</code> in <code>DieNotRolledException.java</code>:</strong> Overriding the <code>getMessage()</code> method without adding any additional functionality is unnecessary. Instead, utilize the constructor to set the exception message.</p>

    <p><span class="suggestion"><strong>Suggestion for Improvement:</strong></span> Remove the overridden <code>getMessage()</code> method and set the exception message in the constructor:</p>

    <div class="code-block">
        <pre>
    /**
     * DieNotRolledException is thrown when attempting to retrieve the value of a die that hasn't been rolled.
     */
    public class DieNotRolledException extends RuntimeException  {
        public DieNotRolledException(){
            super("Die has not been rolled yet.");
        }
    }
        </pre>
    </div>

    <h3>Driver.java</h3>
    <div class="code-block">
        <pre>
    /*
     * Course: CSC1020
     * Lab 2 - Exceptions
     * Die class
     * Name: Chuakun Xiong
     * Last Updated: 9/18/2024
     */
    package xiongchu;

    import java.util.Scanner;

    /**
     * Creates a driver with many methods to performing an experiment
     * to verify the frequency of values generated by rolling a certain collection of dice
     */
    public class Driver {
        /**
         * Holds 10% as a decimal
         */
        public static final double TEN_PERCENT = 0.1;

        /**
         * Holds minimum dice
         */
        public static final int MIN_DICE = 2;
        /**
         * Holds maximum dice
         */
        public static final int MAX_DICE = 10;
        //private static final Scanner scan = new Scanner(System.in);

        public static void main(String[] args) {
            int dieVal1 = 0;
            int dieVal2 = 0;
            boolean continuous = true;
            while (continuous) {
                try {
                    int[] threeValues = getInput();
                    dieVal1 = threeValues[0];
                    dieVal2 = threeValues[1];

                    if (dieVal2 < Die.MIN_SIDES || dieVal2 > Die.MAX_SIDES) {
                        throw new IllegalArgumentException();
                    }
                    if (dieVal1 < MIN_DICE || dieVal1 > MAX_DICE) {
                        throw new DieNotRolledException();
                    }

                    Die[] createdDie = createDie(threeValues[0], threeValues[1]);
                    int[] orderOfRolls = rollDice(createdDie, threeValues[1], threeValues[2]);
                    int maxValue = findMax(orderOfRolls);
                    report(threeValues[0], orderOfRolls, maxValue);
                    continuous = false;

                } catch (NumberFormatException e) {
                    System.err.println("Invalid input: All values must be whole numbers.");
                } catch (IllegalArgumentException e) {
                    System.err.println("Bad die creation: Illegal number of sides: " + dieVal2 + ".");
                } catch (DieNotRolledException e) {
                    System.err.println("currentValue not in the expected range of the Die (2 to 10).");
                } catch (ArrayIndexOutOfBoundsException e) {
                    System.err.println("Too much dice: Illegal number of dice");
                }
            }
        }


        /**
         * Asks the user for three numbers
         *  1. The number of dice to roll in the experiment
         *  2. The number of sides these dice will have
         *  3. How many times the dice will be rolled
         * @return order the list of all three values
         */
        private static int[] getInput() {
            Scanner scan = new Scanner(System.in);
            int[] order = new int[3];
            String stringIntValues = "";
            System.out.println("Please enter the number of dice to roll, how many sides the dice have");
            System.out.println("and how many rolls to complete, separating the values by a space.");
            System.out.println("Example: \"2 6 1000\"");
            stringIntValues = scan.nextLine();

            // loops 3 times till the array is full of values.
            int numPlaceHolder = 0;
            int inc = 0;
            for (int i = 0; i < stringIntValues.length(); i++) {
                if (stringIntValues.charAt(i) == ' ') {
                    order[inc] = Integer.parseInt(stringIntValues.substring(numPlaceHolder, i));
                    numPlaceHolder = i + 1;
                    inc++;
                }
                if (i == stringIntValues.length()-1) {
                    order[inc] = Integer.parseInt(stringIntValues.substring(numPlaceHolder, i + 1));
                }
            }

            /* HELP DEBUGGER */
            //System.out.println(order[0] + " " + order[1] + " " + order[2]);
            return order;
        }

        /**
         * This method will take as parameters the number of dice to create and
         * the number of sides the dice will have, returning an array of Die objects
         * @param numDice gets the number of dice
         * @param numSides gets the numbers of sides
         * @return numOfDice list of Die objects
         */
        private static Die[] createDie(int numDice, int numSides) {
            Die[] numOfDice = new Die[numDice]; // Creates array of the number of Dice
            for (int i = 0; i < numDice; i++) {
                numOfDice[i] = new Die(numSides); // Stores numSides inside each Dice
            }
            return numOfDice; // the number of dice that contains the max amount of values dice can roll
        }

        /**
         * This method will roll all the dice, total up the values, and add to
         * that value's total. It will do this as many times as the user specifies.
         * @param dice gets the array that contains all the Dice
         * @param numSides contains the sides of the dice
         * @param numRolls contains the rolls of the dice
         * @return listOfRolls which counts the occurrences of each roll in a range or integers
         */
        private static int[] rollDice(Die[] dice, int numSides, int numRolls) {
            int total = (dice.length * numSides) - dice.length + 1;
            int[] placeHolder = new int[total]; // Numbers in order
            int[] listOfRolls = new int[total]; // Order of values

            // Sets the boundaries from num dice to max value or dice
            for (int i = 0; i < total; i++) {
                placeHolder[i] = i + dice.length;
            }

            int currentVal = 0;
            for (int i = 0; i < numRolls; i++) {
                for (int j = 0; j < dice.length; j++) {
                    dice[j].roll();
                    currentVal += dice[j].getCurrentValue();
                }
                for (int k = 0; k < total; k++) {
                    if (currentVal == placeHolder[k]) {
                        listOfRolls[k]++;
                    }
                }
                currentVal = 0;
            }

            /* HELP DEBUGGER */
            //for (int i = 0; i < listOfRolls.length; i++) {
            //    System.out.println(placeHolder[i] + " " + storage[i] + " " + listOfRolls[i]);
            //}

            return listOfRolls;
        }

        /**
         * This method will take the array that contains the rolling statistics
         * and find and return the largest count. Which value has
         * the largest count is not important here, just what the count is.
         * @param rolls holds the value of all the rolls
         * @return the max roll value
         */
        private static int findMax(int[] rolls) {
            int maxVal = 0; // Switch to roll[i];
            for (int i = 0; i < rolls.length; i++) {
                if (rolls[i] > maxVal) {
                    maxVal = rolls[i];

                    /* HELP DEBUGGER */
                    //System.out.println(maxVal);
                }
            }
            return maxVal;
        }

        /**
         * This method will print the results as a horizontal bar chart using asterisks
         * @param numDice gets the number of dice
         * @param rolls contains the values with all the rolls to it
         * @param max THEN THIS MUST HOLD THE MAX ROLL (connects with max = maxVal?)
         */
        private static void report(int numDice, int[] rolls, int max) {
            int maxNumRolls = max;

            int numRolls = 0;
            for (int i = 0; i < rolls.length; i++) {
                numRolls += rolls[i];
            }

            // scale is how many rolls is 10% of the max
            double scale = maxNumRolls * TEN_PERCENT;
            // Number of asterisks for a value is the number of rolls divided by the scale
            // DID NOT NEED THIS CODE: int numStars = (int) (numRolls * scale); //

            StringBuilder stars = new StringBuilder();
            for (int i = 0; i < rolls.length; i++) {
                for (int j = 0; j < MAX_DICE; j++) {
                    if (rolls[i] > scale * j) {
                        stars.append("*");
                    }
                }
                System.out.println((String.format("%o\t:\t%o \t\t", i+numDice, rolls[i])) + stars);
                //System.out.println((i + numDice) + ":" + rolls[i] + "          " + stars);
                stars = new StringBuilder();
            }
        }

    }
        </pre>
    </div>

    <p><span class="deduction"><strong>Deduction (0):</strong></span> <strong>Method <code>getInput()</code> in <code>Driver.java</code>:</strong> The method performs multiple responsibilities including input validation, parsing, dice creation, rolling, and reporting. This violates the Single Responsibility Principle, making the method harder to maintain and debug.</p>

    <p><span class="deduction"><strong>Deduction (-0.5):</strong></span> <strong>Input Parsing Logic:</strong> The method attempts to parse user input by removing spaces and extracting substrings based on space indices. This approach is error-prone and can lead to incorrect parsing, especially if the input format varies.</p>

    <p><span class="deduction"><strong>Deduction (-0.5):</strong></span> <strong>Method <code>rollDice()</code> in <code>Driver.java</code>:</strong> The implementation incorrectly initializes the <code>rolls</code> array with a size of <code>numDice*numSides-1</code>, which does not accurately represent the range of possible roll sums. Additionally, the method does not handle potential <code>ArrayIndexOutOfBoundsException</code> if the sum exceeds the array bounds.</p>

    <p><span class="deduction"><strong>Deduction (-0.5):</strong></span> <strong>Method <code>report()</code> in <code>Driver.java</code>:</strong> The calculation for <code>scale</code> as <code>rolls[max] / 10</code> can result in zero, leading to division by zero errors when calculating <code>numStars</code>. Furthermore, the method's logic for generating star strings is unnecessarily convoluted and can be simplified.</p>

    <p><span class="deduction"><strong>Deduction (-0.5):</strong></span> <strong>Method <code>findMax()</code> in <code>Driver.java</code>:</strong> The method efficiently finds the maximum value in the <code>rolls</code> array; however, it does not track the index of the maximum value, which may be necessary for certain operations.</p>

    <p><span class="deduction"><strong>Deduction (-0.5):</strong></span> <strong>Resource Management:</strong> The <code>Scanner</code> instance is created inside the <code>getInput()</code> method without being closed, leading to potential resource leaks.</p>

    <p><span class="deduction"><strong>Deduction (-0.5):</strong></span> <strong>Exception Handling:</strong> The exception handling in the <code>getInput()</code> method catches <code>NumberFormatException</code> but does not handle other potential exceptions such as <code>ArrayIndexOutOfBoundsException</code>, which can occur during input parsing.</p>

    <p><span class="suggestion"><strong>Suggestion for Improvement:</strong></span> 
        <ol>
            <li>Remove the misuse of <code>DieNotRolledException</code> in contexts unrelated to die rolling.</li>
            <li>Replace `%o` with `%d` in all <code>String.format</code> statements to ensure correct decimal formatting.</li>
            <li>Revise the <code>report</code> method to accurately represent roll frequencies without tying it to <code>MAX_DICE</code>.</li>
            <li>Optimize the <code>rollDice</code> method by directly calculating the index for <code>listOfRolls</code> based on the sum, eliminating unnecessary nested loops.</li>
            <li>Close the <code>Scanner</code> instance after use or utilize a try-with-resources statement to prevent resource leaks.</li>
            <li>Correct typographical errors in comments and documentation to maintain professionalism and clarity.</li>
            <li>Ensure that each method adheres to the Single Responsibility Principle by handling only one task.</li>
            <li>Implement comprehensive exception handling to catch and manage all potential exceptions that may arise during input parsing and processing.</li>
            <li>Adjust the size of the <code>rolls</code> array based on the minimum and maximum possible sums to accurately capture all possible roll outcomes.</li>
            <li>Simplify the <code>report</code> method by using built-in string manipulation methods to generate star strings and ensure correct value mapping.</li>
        </ol>
    </p>

    <h2>Final Grade</h2>
    <p class="grade"><strong>Earned:</strong> 93/100</p>
    <ul>
        <li>Intermediate Commits: 15/15</li>
        <li>Technical Quality: 53/60 (Deductions for exception handling misuse, incorrect formatting, logic errors, inefficient implementations, and resource management issues)</li>
        <li>Coding Standard Compliance and Program Clarity: 10/15 (Deductions for typographical errors and variable naming)</li>
        <li>Following Submission Instructions: 10/10</li>
    </ul>

    <p><strong>Overall, you've made a solid effort!</strong> However, please address the highlighted issues to improve the robustness and efficiency of your code. Proper exception handling, adhering to object-oriented principles, and ensuring method responsibilities are crucial for creating maintainable and error-resistant applications.</p>

    <p>If you have any questions about this feedback or need further clarification, please feel free to reach out.</p>

    <p><em>Grader:Dr.Ukegbu</em></p>
</body>
</html>
