/*
 * Course: CSC1020
 * Lab 2 - Exceptions
 * Die class
 * Name: Chuakun Xiong
 * Last Updated: 9/17/2024
 */
package xiongchu;

import java.util.InputMismatchException;
import java.util.Scanner;

/**
 * Creates a driver with many methods to performing an experiment
 * to verify the frequency of values generated by rolling a certain collection of dice
 */
public class Driver {
    /**
     * Holds the minimum side to a die
     */
    public static final int MIN_SIDES = 2;
    /**
     * Holds the maximum side to a die
     */
    public static final int MAX_SIDES = 100;
    /**
     * Holds 10% as a decimal
     */
    public static final double TEN_PERCENT = 0.1;

    /**
     * Holds minimum dice
     */
    public static final int MIN_DICE = 2;
    /**
     * Hols maximum dice
     */
    public static final int MAX_DICE = 10;
    //private static final Scanner scan = new Scanner(System.in);

    public static void main(String[] args) {
        int getMid = 0;
        boolean continuous = true;
        while (continuous) {
            try {

                int[] threeValues = getInput();
                getMid = threeValues[1];
                for (int i = 0; i < threeValues.length; i++) {
                    if (MAX_SIDES < threeValues[i] || threeValues[i] < MIN_SIDES) {
                        throw new IllegalArgumentException("Cannot be less than 2 or greater than 100");
                    }
                }
                Die[] createdDie = createDie(threeValues[0], threeValues[1]);
                int[] orderOfRolls = rollDice(createdDie, threeValues[1], threeValues[2]);
                int maxValue = findMax(orderOfRolls);
                report(threeValues[0], orderOfRolls, maxValue);

            } catch (InputMismatchException e) {
                System.err.println("Invalid input: All values must be whole numbers");
            } catch (IllegalArgumentException e) {
                System.err.println("Bad die creation: Illegal number of sides: " + getMid);
            } catch (DieNotRolledException e) {
                System.err.println("Die not rolled");
            }
        }
    }




    /**
     * Asks the user for three numbers
     *  1. The number of dice to roll in the experiment
     *  2. The number of sides these dice will have
     *  3. How many times the dice will be rolled
     * @return order the list of all three values
     */
    private static int[] getInput() {
        Scanner scan = new Scanner(System.in);
        int[] order = new int[3];
        String stringIntValues = "";
        System.out.println("Please enter the number of dice to roll, how many sides the dice have");
        System.out.println("and how many rolls to complete, separating the values by a space.");
        System.out.println("Example: \"2 6 1000\"");
        stringIntValues = scan.nextLine();

        // loops 3 times till the array is full of values.
        int numPlaceHolder = 0;
        int inc = 0;
        for (int i = 0; i < stringIntValues.length(); i++) {
            if (stringIntValues.charAt(i) == ' ') {
                order[inc] = Integer.parseInt(stringIntValues.substring(numPlaceHolder, i));
                numPlaceHolder = i + 1;
                inc++;
            }
            if (i == stringIntValues.length()-1) {
                order[inc] = Integer.parseInt(stringIntValues.substring(numPlaceHolder, i + 1));
            }
        }

        /* HELP DEBUGGER */
        //System.out.println(order[0] + " " + order[1] + " " + order[2]);
        return order;
    }

    /**
     * This method will take as parameters the number of dice to create and
     * the number of sides the dice will have, returning an array of Die objects
     * @param numDice gets the number of dice
     * @param numSides gets the numbers of sides
     * @return numOfDice list of Die objects
     */
    private static Die[] createDie(int numDice, int numSides) {
        Die[] numOfDice = new Die[numDice]; // Creates array of the number of Dice
        for (int i = 0; i < numDice; i++) {
            numOfDice[i] = new Die(numSides); // Stores numSides inside each Dice
        }
        return numOfDice; // the number of dice that contains the max amount of values dice can roll
    }

    /**
     * This method will roll all the dice, total up the values, and add to
     * that value's total. It will do this as many times as the user specifies.
     * @param dice gets the array that contains all the Dice
     * @param numSides contains the sides of the dice
     * @param numRolls contains the rolls of the dice
     * @return listOfRolls which counts the occurrences of each roll in a range or integers
     */
    private static int[] rollDice(Die[] dice, int numSides, int numRolls) {
        int total = (dice.length * numSides) - MIN_DICE + 1;
        int[] storage = new int[total]; // Creates a list of rolls of all the numbers.
        int[] placeHolder = new int[total]; // Numbers in order
        int[] listOfRolls = new int[total]; // Order of values
        int totalRollPerDice = 0;

        // Sets the boundaries from num dice to max value or dice
        for (int i = 0; i < total; i++) {
            placeHolder[i] = i + dice.length;
        }

        // Cycles through each dice
        for(int i = 0; i < numRolls; i++) {
            // Keeps rolling each dice(set how many rolls) in the array
            for(int j = 0; j < dice.length; j++) {
                dice[j].roll();
                totalRollPerDice += dice[j].getCurrentValue();
            }
            // Sets for each index, the roll value
            storage[i] = totalRollPerDice;
            totalRollPerDice = 0;
        }

        // Puts values in order
        for (int i = 0; i < placeHolder.length; i++) {
            for (int j = 0; j < storage.length; j++) {
                if (placeHolder[i] == storage[j]) {
                    listOfRolls[i]++;
                }
            }
        }

        /* HELP DEBUGGER */
        //for (int i = 0; i < listOfRolls.length; i++) {
        //    System.out.println(placeHolder[i] + " " + storage[i] + " " + listOfRolls[i]);
        //}

        return listOfRolls;
    }

    /**
     * This method will take the array that contains the rolling statistics
     * and find and return the largest count. Which value has
     * the largest count is not important here, just what the count is.
     * @param rolls holds the value of all the rolls
     * @return the max roll value
     */
    private static int findMax(int[] rolls) {
        int maxVal = 0; // Switch to roll[i];
        for (int i = 0; i < rolls.length; i++) {
            if (rolls[i] > maxVal) {
                maxVal = rolls[i];

                /* HELP DEBUGGER */
                //System.out.println(maxVal);
            }
        }
        return maxVal;
    }

    /**
     * This method will print the results as a horizontal bar chart using asterisks
     * @param numDice gets the number of dice
     * @param rolls contains the values with all the rolls to it
     * @param max THEN THIS MUST HOLD THE MAX ROLL (connects with max = maxVal?)
     */
    private static void report(int numDice, int[] rolls, int max) {
        int maxNumRolls = max;

        int numRolls = 0;
        for (int i = 0; i < rolls.length; i++) {
            numRolls += rolls[i];
        }

        // scale is how many rolls is 10% of the max
        double scale = maxNumRolls * TEN_PERCENT;
        // Number of asterisks for a value is the number of rolls divided by the scale
        int numStars = (int) (numRolls * scale); //

        StringBuilder stars = new StringBuilder();
        for (int i = 0; i < rolls.length; i++) {
            for (int j = 0; j < MAX_DICE; j++) {
                if (rolls[i] > scale * j) {
                    stars.append("*");
                }
            }
            System.out.println((i + numDice) + ":" + rolls[i] + "          " + stars);
            stars = new StringBuilder();
        }
    }

}

